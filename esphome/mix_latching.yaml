substitutions:
  adc_attenuation: 12db 
  debounce_interval: 30
  throtle_interval: 75
  update_interval: 10
  adc_samples: 16       #JFYI: max sample rate about 6k
  click_timing_single: [ON for at most 0.5s, OFF for at least 0.2s]
  click_timing_double: [ON for at most 0.5s, OFF for at most 0.4s, ON for at most 0.5s]
  click_timing_long:   [ON for at least 0.8s] 
esphome:
  name: mix
  friendly_name: Mixer
  min_version: 2025.12.5
  name_add_mac_suffix: false
  platformio_options:
    build_flags: -DBOARD_HAS_PSRAM
    board_build.flash_mode: dio
    board_upload.maximum_size: 16777216
  project: 
    name: esphome.web
    version: stable
  includes:
    - mix_tools.hpp
    - mix_tools.cpp

  on_boot: 
    then:
      - lambda: |-
         //set_extra_uart(extra_uart); // uncomment to use extra_uart
         set_vref(vref);
  
esp32:
  board: esp32-s3-devkitc-1
  variant: ESP32S3  
  flash_size: 16MB
  cpu_frequency: 240Mhz
  framework:
    type: esp-idf
    version: recommended
    advanced:
      compiler_optimization: PERF
    sdkconfig_options:
      # --- priorities  ----------------------------------------------------
      CONFIG_ESP_WIFI_TASK_PRIORITY: "7"    # default: 5
      CONFIG_ESP_MAIN_TASK_PRIORITY: "3"    # default: 5
      CONFIG_ESP_LWIP_TCPIP_TASK_PRIORITY: "6"
      
      # --- Wi-Fi CPU affinity & performance -------------------------------
      CONFIG_ESP_WIFI_TASK_CORE_ID: "0"               # Move Wi-Fi driver to core 0 (reduces interference with ADC & user code)
      CONFIG_ESP_MAIN_TASK_AFFINITY_CPU0: "y"         # Keep main task on core 0 for predictable scheduling
      CONFIG_ESP_MAIN_TASK_STACK_SIZE: "8192"         # Larger stack for heavy computation & web server

      # --- IRAM optimizations ---------------------------------------------
      CONFIG_ESP_WIFI_IRAM_OPT: "y"                   # Put Wi-Fi critical functions in IRAM for lower latency
      CONFIG_ESP_WIFI_RX_IRAM_OPT: "y"                # Put Wi-Fi RX routines in IRAM (helps reduce ping jitter)
      CONFIG_LWIP_IRAM_OPTIMIZATION: "y"              # Place parts of lwIP into IRAM for faster packet processing

      # --- Wi-Fi buffering & throughput -----------------------------------
      CONFIG_ESP_WIFI_DYNAMIC_RX_BUFFER_NUM: "32"     # Increase RX buffer count (default = 10), smoother under load
      CONFIG_ESP_WIFI_STATIC_RX_BUFFER_NUM: "10"      # Keep static buffer pool reasonably sized
      CONFIG_ESP_WIFI_TX_BUFFER_TYPE: "1"             # 1 = static TX buffers (more stable, less jitter on S3)
      CONFIG_ESP_WIFI_STATIC_TX_BUFFER_NUM: "32"      # TX buffer count

      # --- Memory and heap stability --------------------------------------
      CONFIG_ESP_SYSTEM_MEMPROT_FEATURE: "n"          # Disable mem-protection overhead (safe for controlled systems)
      CONFIG_SPIRAM_MALLOC_ALWAYSINTERNAL: "32768"    # Guarantee 32 KB fast internal RAM (for ISR, Wi-Fi, lwIP)
      CONFIG_SPIRAM_MALLOC_RESERVE_INTERNAL: "32768"  # Reserve internal memory primarily for networking

      # --- PSRAM tuning ---------------------------------------------------
      CONFIG_SPIRAM_FETCH_INSTRUCTIONS: "y"           # Allow fetching instructions from PSRAM when safe
      CONFIG_SPIRAM_RODATA: "y"                       # Move constant data to PSRAM to free IRAM/DRAM
      CONFIG_SPIRAM_SPEED_80M: "y"                    # Ensure 80MHz PSRAM mode (more stable on S3)
      CONFIG_SPIRAM_MODE_OCT: "y"                     # Octal PSRAM mode (matches your config)

      # --- Disable unused Wi-Fi features (free up RAM/CPU) ----------------
      CONFIG_ESP_WIFI_SOFTAP_SUPPORT: "n"             # Disable SoftAP 
      CONFIG_ESP_WIFI_ENABLE_WPA3_SAE: "n"            # Disable WPA3 (heavy on CPU & memory)

      # --- Networking stack tuning ----------------------------------------
      CONFIG_LWIP_TCP_QUEUE_OOSEQ: "n"                # Disable out-of-order queue (saves RAM, improves latency)
      CONFIG_LWIP_CHECKSUM_CHECK_ICMP: "n"            # Skip extra ICMP validations (reduces ping jitter)
      CONFIG_LWIP_TCPIP_TASK_STACK_SIZE: "4096"       # Larger TCP/IP thread stack for stability
      CONFIG_LWIP_TCPIP_TASK_AFFINITY_CPU0: "y"       # Keep lwIP on core 0 with Wi-Fi
  
psram:
  mode: octal
  speed: 80MHz

web_server:
  port: 80
  version: 3
  log: False
  local: True
  include_internal: false

# Enable logging (required for improv_serial component)
logger:
  level: WARN
  baud_rate: 115200

# Optional: Enable extra uart which can be used for extra wired communications (alse, uncomment set_extra_uart in on_boot section, and USE_EXTRA_UART in mix_tools.h!)
# uart:
#   - id: extra_uart
#     tx_pin: GPIO41
#     rx_pin: GPIO42
#     baud_rate: 115200

# Optional: Enable Home Assistant API (you can use sliders/switches to control your HA devices)
# api:

# Optional: Enable OTA updates (set ota_password in secrets xml)
# ota:
# - platform: esphome
#   id: my_ota
#   password: !secret ota_password

# WiFi config. Option 1: Enable wifi (hardcoded credentials)
# wifi:
#  id: wifi_module
#  output_power: 8.5db
#  power_save_mode: none
#  fast_connect: true
#  ssid: !secret wifi_ssid
#  password: !secret wifi_password
#  ap:
#    ssid: "Mixer Fallback Hotspot"
#    password: !secret fallback_password

# WiFi config. Option 2 (production preffered): wifi ssid and password should be configured via https://web.esphome.io/ by improv_serial (you can do it any time after flashing)
wifi:
  id: wifi_module
  output_power: 8.5db
  power_save_mode: none
improv_serial:
  next_url: http://{{device_name}}/

# Optional: Enable captive portal (fallback hotspot) !!! you should remove "CONFIG_ESP_WIFI_SOFTAP_SUPPORT" from sdkconfig_options !!!
# captive_portal:

# wifi status led
switch:
  - platform: gpio
    id: WiFiLed
    internal: True
    pin: 
      number: GPIO48
      inverted: True
      mode: OUTPUT_OPEN_DRAIN

interval:
  - interval: 333ms
    then:
      - lambda: |-
          if (id(wifi_module).is_connected()) { 
            id(WiFiLed).turn_off(); 
          } else 
          if (id(wifi_module).has_sta()) { 
            id(WiFiLed).toggle();
          } else {                 
            id(WiFiLed).turn_on(); 
          } 
  - interval: 1s
    then:
      - lambda: |-
          hostsend_all();
  - interval: 10s
    then:
      - lambda: |-
          auto info = id(wifi_module).wifi_rssi();
          ESP_LOGI("wifi", "RSSI: %d dBm", info);

#Optional: factory reset button (reset settings)
# button:
#  - platform: factory_reset
#    icon: "mdi:restart-alert"
#    name: Restart with Factory Default Settings

sensor:
  - platform: wifi_signal
    id: wifi_signal_db
    internal: true
    update_interval: 5s

  - platform: copy 
    source_id: wifi_signal_db
    name: "WiFi strength"
    filters:
      - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
    unit_of_measurement: "%"

  - platform: adc
    id: vref
    internal: true
    pin: GPIO8
    attenuation: ${adc_attenuation}
    update_interval: ${update_interval}ms
    samples: ${adc_samples}
    raw: true

  - platform: template
    id: pot0
    name: "pot0"
    unit_of_measurement: "%"
    accuracy_decimals: 0
  - platform: adc
    id: s0_v
    internal: true
    pin: GPIO1
    attenuation: ${adc_attenuation}
    update_interval: ${update_interval}ms
    samples: ${adc_samples}
    raw: true
    on_value:
      then:
        - lambda: |-
            process_pot(0, id(s0_v), id(pot0), (uint16_t)x, ${update_interval}, ${throtle_interval}, false);

  - platform: template
    id: pot1
    name: "pot1"
    unit_of_measurement: "%"
    accuracy_decimals: 0
  - platform: adc
    id: s1_v
    internal: true
    pin: GPIO2
    attenuation: ${adc_attenuation}
    update_interval: ${update_interval}ms
    samples: ${adc_samples}
    raw: true
    on_value:
      then:
        - lambda: |-
            process_pot(1, id(s1_v), id(pot1), (uint16_t)x, ${update_interval}, ${throtle_interval}, false);

  - platform: template
    id: pot2
    name: "pot2"
    unit_of_measurement: "%"
    accuracy_decimals: 0
  - platform: adc
    id: s2_v
    internal: true
    pin: GPIO4
    attenuation: ${adc_attenuation}
    update_interval: ${update_interval}ms
    samples: ${adc_samples}
    raw: true
    on_value:
      then:
        - lambda: |-
            process_pot(2, id(s2_v), id(pot2), (uint16_t)x, ${update_interval}, ${throtle_interval}, false);

  - platform: template
    id: pot3
    name: "pot3"
    unit_of_measurement: "%"
    accuracy_decimals: 0
  - platform: adc
    id: s3_v
    internal: true
    pin: GPIO5
    attenuation: ${adc_attenuation}
    update_interval: ${update_interval}ms
    samples: ${adc_samples}
    raw: true
    on_value:
      then:
        - lambda: |-
            process_pot(3, id(s3_v), id(pot3), (uint16_t)x, ${update_interval}, ${throtle_interval}, false);

  - platform: template
    id: pot4
    name: "pot4"
    unit_of_measurement: "%"
    accuracy_decimals: 0
  - platform: adc
    id: s4_v
    internal: true
    pin: GPIO6
    attenuation: ${adc_attenuation}
    update_interval: ${update_interval}ms
    samples: ${adc_samples}
    raw: true
    on_value:
      then:
        - lambda: |-
            process_pot(4, id(s4_v), id(pot4), (uint16_t)x, ${update_interval}, ${throtle_interval}, false);

  - platform: template
    id: pot5
    name: "pot5"
    unit_of_measurement: "%"
    accuracy_decimals: 0
  - platform: adc
    id: s5_v
    internal: true
    pin: GPIO7
    attenuation: ${adc_attenuation}
    update_interval: ${update_interval}ms
    samples: ${adc_samples}
    raw: true
    on_value:
      then:
        - lambda: |-
            process_pot(5, id(s5_v), id(pot5), (uint16_t)x, ${update_interval}, ${throtle_interval}, false);

binary_sensor:
  - platform: gpio
    id: sw0
    name: "sw0"
    pin:
      number: GPIO9
      mode:
        input: true
        pullup: true
    filters:
      - delayed_on: ${debounce_interval}ms
      - delayed_off: ${debounce_interval}ms
      - lambda: |-
          return process_sw(0, x);

  - platform: gpio
    id: sw1
    name: "sw1"
    pin:
      number: GPIO10
      mode:
        input: true
        pullup: true
    filters:
      - delayed_on: ${debounce_interval}ms
      - delayed_off: ${debounce_interval}ms
      - lambda: |-
          return process_sw(1, x);

  - platform: gpio
    id: sw2
    name: "sw2"
    pin:
      number: GPIO11
      mode:
        input: true
        pullup: true
    filters:
      - delayed_on: ${debounce_interval}ms
      - delayed_off: ${debounce_interval}ms
      - lambda: |-
          return process_sw(2, x);

  - platform: gpio
    id: sw3
    name: "sw3"
    pin:
      number: GPIO12
      mode:
        input: true
        pullup: true
    filters:
      - delayed_on: ${debounce_interval}ms
      - delayed_off: ${debounce_interval}ms
      - lambda: |-
          return process_sw(3, x);

  - platform: gpio
    id: sw4
    name: "sw4"
    pin:
      number: GPIO13
      mode:
        input: true
        pullup: true
    filters:
      - delayed_on: ${debounce_interval}ms
      - delayed_off: ${debounce_interval}ms
      - lambda: |-
          return process_sw(4, x);

  - platform: gpio
    id: sw5
    name: "sw5"
    pin:
      number: GPIO14
      mode:
        input: true
        pullup: true
    filters:
      - delayed_on: ${debounce_interval}ms
      - delayed_off: ${debounce_interval}ms
      - lambda: |-
          return process_sw(5, x);

  - platform: gpio
    id: btn0
    pin:
      number: GPIO15
      mode: INPUT_PULLUP
      inverted: true
    filters:
      - delayed_on: ${debounce_interval}ms
      - delayed_off: ${debounce_interval}ms      
    on_multi_click:
      - timing: ${click_timing_single}
        then:
          - script.execute: {id: update_btn_state, btn: 0, value: "single"}
      - timing: ${click_timing_double}
        then:
          - script.execute: {id: update_btn_state, btn: 0, value: "double"}
      - timing: ${click_timing_long}
        then:
          - script.execute: {id: update_btn_state, btn: 0, value: "long"}

  - platform: gpio
    id: btn1
    pin:
      number: GPIO16
      mode: INPUT_PULLUP
      inverted: true
    filters:
      - delayed_on: ${debounce_interval}ms
      - delayed_off: ${debounce_interval}ms      
    on_multi_click:
      - timing: ${click_timing_single}
        then:
          - script.execute: {id: update_btn_state, btn: 1, value: "single"}
      - timing: ${click_timing_double}
        then:
          - script.execute: {id: update_btn_state, btn: 1, value: "double"}
      - timing: ${click_timing_long}
        then:
          - script.execute: {id: update_btn_state, btn: 1, value: "long"}

  - platform: gpio
    id: btn2
    pin:
      number: GPIO17
      mode: INPUT_PULLUP
      inverted: true
    filters:
      - delayed_on: ${debounce_interval}ms
      - delayed_off: ${debounce_interval}ms      
    on_multi_click:
      - timing: ${click_timing_single}
        then:
          - script.execute: {id: update_btn_state, btn: 2, value: "single"}
      - timing: ${click_timing_double}
        then:
          - script.execute: {id: update_btn_state, btn: 2, value: "double"}
      - timing: ${click_timing_long}
        then:
          - script.execute: {id: update_btn_state, btn: 2, value: "long"}

  - platform: gpio
    id: btn3
    pin:
      number: GPIO18
      mode: INPUT_PULLUP
      inverted: true
    filters:
      - delayed_on: ${debounce_interval}ms
      - delayed_off: ${debounce_interval}ms      
    on_multi_click:
      - timing: ${click_timing_single}
        then:
          - script.execute: {id: update_btn_state, btn: 3, value: "single"}
      - timing: ${click_timing_double}
        then:
          - script.execute: {id: update_btn_state, btn: 3, value: "double"}
      - timing: ${click_timing_long}
        then:
          - script.execute: {id: update_btn_state, btn: 3, value: "long"}

  - platform: gpio
    id: btn4
    pin:
      number: GPIO21
      mode: INPUT_PULLUP
      inverted: true
    filters:
      - delayed_on: ${debounce_interval}ms
      - delayed_off: ${debounce_interval}ms      
    on_multi_click:
      - timing: ${click_timing_single}
        then:
          - script.execute: {id: update_btn_state, btn: 4, value: "single"}
      - timing: ${click_timing_double}
        then:
          - script.execute: {id: update_btn_state, btn: 4, value: "double"}
      - timing: ${click_timing_long}
        then:
          - script.execute: {id: update_btn_state, btn: 4, value: "long"}

  - platform: gpio
    id: btn5
    pin:
      number: GPIO40
      mode: INPUT_PULLUP
      inverted: true
    filters:
      - delayed_on: ${debounce_interval}ms
      - delayed_off: ${debounce_interval}ms      
    on_multi_click:
      - timing: ${click_timing_single}
        then:
          - script.execute: {id: update_btn_state, btn: 5, value: "single"}
      - timing: ${click_timing_double}
        then:
          - script.execute: {id: update_btn_state, btn: 5, value: "double"}
      - timing: ${click_timing_long}
        then:
          - script.execute: {id: update_btn_state, btn: 5, value: "long"}

text_sensor:
  - platform: template
    id: last_btn_state
    name: "last_btn_state"

script:
  - id: update_btn_state
    parameters:
      btn: int
      value: string
    then:
      - text_sensor.template.publish:
          id: last_btn_state
          state: !lambda |-
            return process_btn((int)btn, value.c_str());
      - text_sensor.template.publish:
          id: last_btn_state
          state: ""

